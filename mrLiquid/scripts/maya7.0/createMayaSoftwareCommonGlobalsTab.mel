// Copyright (C) 1997-2004 Alias Systems Corp.
// 
// The information in this file is provided for the exclusive use of the
// licensees of Alias.  Such users have the right to use, modify,
// and incorporate this code into other products for purposes authorized
// by the Alias license agreement, without fee.
// 
// ALIAS DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
// INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
// EVENT SHALL ALIAS BE LIABLE FOR ANY SPECIAL, INDIRECT OR
// CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
// DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
// TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
// PERFORMANCE OF THIS SOFTWARE.

// ----------------------------------------------------------------------------
// Utility procedures used by other procedures in this file.
// Must be used to account for multiple instances of the same tab.
//
global proc setParentToCommonTab()
{
	// First set the parent to the correct tab layout.
	// Account for the special "all renderers" master layer layout
	// when we are using render layers
	global string $gMasterLayerRendererName;
	string $renderer = isDisplayingAllRendererTabs() ? $gMasterLayerRendererName : `currentRenderer`;
	string $tabLayout = rendererTabLayoutName($renderer);
	setParent $tabLayout;

	// Now set the parent to the correct column layout
	setParent commonTabColumn;
}

// ----------------------------------------------------------------------------
// Code to create and update the file name preview area 
//

proc createTargetFilePreview()
{
	string $oldParent = `setParent -query`;
		
	columnLayout 
		-adjustableColumn true
		targetFilePreview;

		text 
			-align "left" 
			-font "smallBoldLabelFont" 
			-label "Path" 
			exampleText0;
		text 
			-align "left" 
			-font "smallBoldLabelFont" 
			-label "File Name" 
			exampleText1;
		text 
			-align "left" 
			-font "smallBoldLabelFont" 
			-label "To" 
			exampleText2;
		text 
			-align "left" 
			-font "smallBoldLabelFont" 
			-label "Image Size" 
			exampleText3;

	setParent $oldParent;

	// This target file preview is affected by a number of attributes.
	// If any of those attributes change, this preview needs to be updated.
	//
	// Here we fill an array with the names of all of the current renderer's 
	// attributes which affect the naming of the target file.
	//
	string $attrArray[];

	$attrArray[size($attrArray)] = "defaultRenderGlobals.imageFilePrefix";
	$attrArray[size($attrArray)] = "defaultRenderGlobals.outFormatControl";
	$attrArray[size($attrArray)] = "defaultRenderGlobals.imageFormat";
	$attrArray[size($attrArray)] = "defaultRenderGlobals.imfPluginKey";
	$attrArray[size($attrArray)] = "defaultRenderGlobals.outFormatExt";
	$attrArray[size($attrArray)] = "defaultRenderGlobals.animation";
	$attrArray[size($attrArray)] = "defaultRenderGlobals.imageFormat";
	$attrArray[size($attrArray)] = "defaultRenderGlobals.byFrameStep";
	$attrArray[size($attrArray)] = "defaultRenderGlobals.extensionPadding";
	$attrArray[size($attrArray)] = "defaultRenderGlobals.startFrame";
	$attrArray[size($attrArray)] = "defaultRenderGlobals.endFrame";
	$attrArray[size($attrArray)] = "defaultRenderGlobals.modifyExtension";
	$attrArray[size($attrArray)] = "defaultRenderGlobals.startExtension";
	$attrArray[size($attrArray)] = "defaultRenderGlobals.byExtension";
	$attrArray[size($attrArray)] = "defaultRenderGlobals.periodInExt";
	$attrArray[size($attrArray)] = "defaultResolution.fields";
	$attrArray[size($attrArray)] = "defaultRenderGlobals.fieldExtControl";
	$attrArray[size($attrArray)] = "defaultRenderGlobals.oddFieldExt";
	$attrArray[size($attrArray)] = "defaultRenderGlobals.evenFieldExt";
	$attrArray[size($attrArray)] = "defaultRenderGlobals.putFrameBeforeExt";
	$attrArray[size($attrArray)] = "defaultResolution.width";
	$attrArray[size($attrArray)] = "defaultResolution.height";
	$attrArray[size($attrArray)] = "defaultResolution.dotsPerInch";
	$attrArray[size($attrArray)] = "defaultResolution.imageSizeUnits";
	$attrArray[size($attrArray)] = "defaultResolution.pixelDensityUnits";

	// Now we establish scriptJobs to invoke the procedure which updates the
	// target file preview when any of the above attributes change.
	//
	int $i;

	for ($i = 0; $i < size($attrArray); $i++)
	{
		scriptJob
			-attributeChange 
				$attrArray[$i]
				"updateMayaSoftwareTargetFilePreview"
			-parent targetFilePreview;
	}

	scriptJob 
		-parent targetFilePreview
		-event 
			workspaceChanged 
			"updateMayaSoftwareTargetFilePreview";
}

global proc updateMayaSoftwareTargetFilePreview()
{
	//
	// Description:
	//	This procedure is called any time an attribute change occurs which 
	// 	would affect the name(s) of the file(s) that would be created when the
	// 	user performs a render.
	//	This procedure updates the lines of text in the General tab that allow
	//	the user to see what files are going to be created when they render.
	//

	string $oldParent = `setParent -query`;

	global string $gMasterLayerRendererName;
	string $renderer = isDisplayingAllRendererTabs() ? $gMasterLayerRendererName : `currentRenderer`;
	string $tabLayout = rendererTabLayoutName($renderer);
	if( `tabLayout -exists $tabLayout` )	setParent $tabLayout;

	//
	// Update the Path portion of the preview.
	//

	// get the project's image directory
	//
	string $imgDir = `workspace -q -rte "images"`;
	string $fullPath = `workspace -expandName $imgDir`;
	$path = "  Path: "+ $fullPath + "/";
	text -edit -label $path exampleText0;

	//
	// Update the File Name portion of the preview.
	//

	string $title1 = "  File Name:  ";
	string $title2 = "  To:             ";
	// TODO: DEFINE FIELDS FOR SW RENDER
	string $images[] = `renderSettings -fin -lin`;
	text -edit -label ($title1+$images[0]) exampleText1;
	if ($images[1] != "")
		text -edit -label ($title2+$images[1]) exampleText2;
	else
		text -edit -label "" exampleText2;

	//
	// Update the Image Size portion of the preview.
	//

	// Get attributes
	//
	int $width = `getAttr defaultResolution.width`;
	int $height = `getAttr defaultResolution.height`;
	float $dpi = `getAttr defaultResolution.dotsPerInch`;
	int $sizeUnits = `getAttr defaultResolution.imageSizeUnits`;
	int $resUnits = `getAttr defaultResolution.pixelDensityUnits`;
	
	// Default measurement units to inches if pixels selected
	if( $sizeUnits == 0 ) $sizeUnits = 1;

	global string $gMeasurementUnitsNames[];
	global string $gResolutionUnitsNames[];

	if (size($gResolutionUnitsNames) == 0)
	{
		eval("source resolutionFormats");
	}

	// Convert from pixels to the correct measurement units
	float $docWidth = convertMeasurement(
		convertPixelsToInches( $width, $dpi ),
		"inches",
		$gMeasurementUnitsNames[$sizeUnits]
	);
	float $docHeight = convertMeasurement(
		convertPixelsToInches( $height, $dpi ),
		"inches",
		$gMeasurementUnitsNames[$sizeUnits]
	);

	// Convert from DPI to the correct resolution units
	float $res = convertResolutionMeasurement(
		$dpi,
		"pixels/inch",
		$gResolutionUnitsNames[$resUnits]
	);
	
	// Convert to strings, rounding applicable floats to 1 decimal place
	string $imW = $width;
	string $imH = $height;
	string $docW = setDecimalPrecision( $docWidth, 1 );
	string $docH = setDecimalPrecision( $docHeight, 1 );
	string $units = $gMeasurementUnitsNames[$sizeUnits];
	string $resVal = setDecimalPrecision( $res, 1 );
	string $resUnitsStr = $gResolutionUnitsNames[$resUnits];

	string $imageSizeString = "  Image Size: " + $imW + " x " + $imH
		+ " (" + $docW + " x " + $docH + " " + $units + " " + $resVal
		+ " " + $resUnitsStr + " )";
		
	text -edit -label $imageSizeString exampleText3;

	setParent $oldParent;
}

// ----------------------------------------------------------------------------
// Code to create and update the Image File Output frame 
//

proc createFileNamePrefixControl()
{
	// Create the control
	//
	textFieldGrp 
		-label "File Name Prefix" 
		-changeCommand ("changeMayaSoftwareFileNamePrefix")
		mayaSoftwareFileName;

	// connect the label, so we can change its color
	connectControl -index 1 mayaSoftwareFileName defaultRenderGlobals.imageFilePrefix;
	// connect the text field, so it will always match the attribute
	connectControl -index 2 mayaSoftwareFileName defaultRenderGlobals.imageFilePrefix;

	// Create a scriptJob which will update the control when the value of the
	// attribute it represents is changed.
	//
	scriptJob
		-parent mayaSoftwareFileName
		-attributeChange 
			"defaultRenderGlobals.imageFilePrefix"
			"updateMayaSoftwareFileNamePrefixControl";
}

global proc changeMayaSoftwareFileNamePrefix()
{
	string $oldParent = `setParent -query`;
	setParentToCommonTab();

	string $prefix = `textFieldGrp -query -text mayaSoftwareFileName`;
	string $prefixAttr = "defaultRenderGlobals.imageFilePrefix";

	if (	$prefix != "(not set; using filename)"
		&& 	isValidFileNamePrefix($prefix)) 
	{
		// The user has set the prefix to something, and it is a valid name, so
		// we will set the value of the corresponding attribute.
		//
		setAttr $prefixAttr -type "string" $prefix;
	}
	else
	{
		// The user has set the prefix to an invalid value. We will refresh the
		// UI to show the current value, which has not been changed.
		//
		updateMayaSoftwareFileNamePrefixControl();
	}

	setParent $oldParent;
}

global proc updateMayaSoftwareFileNamePrefixControl()
//
//  Procedure Name:
//      changeFileName
//
//  Description:
//		This procedure is called when the user changes the file
//		prefix.  It sets the internal representation of the prefix
//		and then updates the example to show the changes.
//
{
	string $oldParent = `setParent -query`;

	setParentToCommonTab();

	string $prefixAttr = "defaultRenderGlobals.imageFilePrefix";

	string $prefix = `getAttr $prefixAttr`;

	if (size($prefix) > 0) 
	{
		textFieldGrp -edit -text $prefix mayaSoftwareFileName;
	} 
	else 
	{
		textFieldGrp -edit -text "(not set; using filename)" mayaSoftwareFileName;
	}

	setParent $oldParent;
}

proc createFileNameFormatControl()
{
	optionMenuGrp 
		-label "Frame/Animation Ext" 
		-changeCommand ("changeMayaSoftwareFileNameFormat")
		extMenu;

		menuItem -label "name (Single Frame)"; 
		menuItem -label "name.ext (Single Frame)"; 
		menuItem -label "name.#.ext" mayaSoftwareNameDotFrameDotExtension;
		menuItem -label "name.ext.#" mayaSoftwareNameDotExtensionDotFrame;	
		menuItem -label "name.#" mayaSoftwareNameDotFrame;	
		menuItem -label "name#.ext" mayaSoftwareFrameDotExtension;	
		menuItem -label "name_#.ext" mayaSoftwareNameUnderFrameDotExtension;
		menuItem -label "name (Multi Frame)" mayaSoftwareMultiFrame;	
		menuItem -label "name.ext (Multi Frame)" 
            mayaSoftwareMultiFrameDotExtension;	

	string $attrArray[];

	$attrArray[size($attrArray)] = "defaultRenderGlobals.outFormatControl";
	$attrArray[size($attrArray)] = "defaultRenderGlobals.animation";
	$attrArray[size($attrArray)] = "defaultRenderGlobals.periodInExt";
	$attrArray[size($attrArray)] = "defaultRenderGlobals.putFrameBeforeExt";
	$attrArray[size($attrArray)] = "defaultRenderGlobals.imageFormat";
	$attrArray[size($attrArray)] = "defaultRenderGlobals.imfPluginKey";

	// Now we establish scriptJobs to invoke the procedure which updates the
	// file name format control when any of the above attributes change.
	//
	int $i;

	for ($i = 0; $i < size($attrArray); $i++)
	{
		scriptJob
			-attributeChange 
				$attrArray[$i]
				"updateMayaSoftwareFileNameFormatControl"
			-parent extMenu;
	}
}

global proc changeMayaSoftwareFileNameFormat()
//
//  Procedure Name:
//      changeExtension
//
//  Description:
//		This procedure is called when the user changes the format
//		of the file extension.  It sets the internal representation 
//		and then updates the example to show the changes.
//
//	Note:
//		Although the user sees only one control to change the
//		extension, it actually affects more than one value.
//
{
	string $oldParent = `setParent -query`;
	setParentToCommonTab();

	int $item = `optionMenuGrp -q -sl extMenu`;

    setMayaSoftwareFrameExt($item, 0);

	// Update the batch render window if it exists
	//
	if (`exists updateBatchRenderWindowTitle`)
	{
		updateBatchRenderWindowTitle();
	}

	setParent $oldParent;
}

global proc updateMayaSoftwareFileNameFormatControl()
{
	string $oldParent = `setParent -query`;

	setParentToCommonTab();

	int $frameBeforeExt	= `getAttr "defaultRenderGlobals.putFrameBeforeExt"`;
	int $useAnim 		= `getAttr "defaultRenderGlobals.animation"`;
	int $imageUse 		= `getAttr "defaultRenderGlobals.outFormatControl"`;
	int $period 		= `getAttr "defaultRenderGlobals.periodInExt"`;

	int $multiframe = multiframeFormat(getImfImageType());
	int $psdFormat = 0;
	if (`getAttr defaultRenderGlobals.imageFormat` == 31) // Check if PSD format
	{
		$multiframe = 0;		
		$psdFormat = 1;
	}

	int $activeMenuItem = 0;

    // Update Frame/Animation Ext menuItems and enable only the relevant ones.
    //
    int $notMultiFrameOrPsd = !$multiframe || $psdFormat;
    
	menuItem -edit -enable ($notMultiFrameOrPsd) mayaSoftwareNameDotFrameDotExtension;
	menuItem -edit -enable ($notMultiFrameOrPsd) mayaSoftwareNameDotExtensionDotFrame;	
	menuItem -edit -enable ($notMultiFrameOrPsd) mayaSoftwareNameDotFrame;	
	menuItem -edit -enable ($notMultiFrameOrPsd) mayaSoftwareFrameDotExtension;
	menuItem -edit -enable ($notMultiFrameOrPsd) mayaSoftwareNameUnderFrameDotExtension;
	menuItem -edit -enable ($multiframe) mayaSoftwareMultiFrame;	
	menuItem -edit -enable ($multiframe) mayaSoftwareMultiFrameDotExtension;

    if ($multiframe)
    {
		if ($useAnim)
		{
		    if ($imageUse == 1)     // no extension
		    {
			    $activeMenuItem = 8;
		    }
            else
		    {
			    $activeMenuItem = 9;
		    }
        }
        else
        {
		    if ($imageUse == 1)     // no extension
		    {
			    $activeMenuItem = 1;
		    }
            else
		    {
			    $activeMenuItem = 2;
		    }
        }
    }
    else
    {
		if ($useAnim)
		{
			if ($imageUse == 1)
			{
				$activeMenuItem = 5;
			}
			else
			{
				if ($frameBeforeExt == 0)
				{
					$activeMenuItem = 4;
				} 
				else 
				{
					if ($period == 1) // period in extension
					{
						$activeMenuItem = 3;
					}
					else if ($period == 2) // underscore in extension
					{
						$activeMenuItem = 7;
					}
					else // $period == 0
					{
						$activeMenuItem = 6;
					}
				}
			}
		} 
		else 
		{
			if ($imageUse == 1)
			{
				$activeMenuItem = 1;
			} 
			else 
			{
				$activeMenuItem = 2;
			}
		}
    }
	
	optionMenuGrp -edit -sl $activeMenuItem extMenu;

	// Also update the frame number controls to enable/disable them according
	// to whether or not they are being used.
	//
	updateMayaSoftwareFrameNumberControls();

	setParent $oldParent;
}

proc createUseCustomExtensionControl()
{
	checkBoxGrp 
		-numberOfCheckBoxes 1
		-label ""
		-label1 "Use Custom Extension:" 
		-changeCommand "changeMayaSoftwareUseCustomExtension"
		useCustomExtensionCtrl;

	connectControl -index 2 useCustomExtensionCtrl defaultRenderGlobals.outFormatControl;

	scriptJob 
		-parent useCustomExtensionCtrl 
		-attributeChange "defaultRenderGlobals.outFormatControl" 
		"updateMayaSoftwareUseCustomExtensionControl";
}

global proc updateMayaSoftwareUseCustomExtensionControl()
{
	string $oldParent = `setParent -query`;

	setParentToCommonTab();

	int $useImage = (`getAttr "defaultRenderGlobals.outFormatControl"` != 1);

	checkBoxGrp 
		-edit 
		-value1 (`getAttr "defaultRenderGlobals.outFormatControl"` == 2)
		-enable $useImage
		useCustomExtensionCtrl;

	setParent $oldParent;
}

global proc changeMayaSoftwareUseCustomExtension()
{
// TODO: Update docs
//
//  Procedure Name:
//      changeCustomExtensionCheck
//
//  Description:
//		This procedure is called when the user turns the custom 
//		extension on or off.  It sets the internal representation 
//		and then updates the example to show the changes.
//
	string $oldParent = `setParent -query`;
	setParentToCommonTab();

	int $isOn = `checkBoxGrp -query -value1 useCustomExtensionCtrl`;

	if ($isOn) 
	{
		setAttr defaultRenderGlobals.outFormatControl 2;
	} 
	else 
	{
		// We have to figure out if there should be an extension
		// at all or not. 
		//
		int $item = `optionMenuGrp -query -select extMenu`;

		if ($item == 1 || $item == 5) 
		{
			setAttr defaultRenderGlobals.outFormatControl 1;
		} 
		else 
		{
			setAttr defaultRenderGlobals.outFormatControl 0;
		}
	}   

	setParent $oldParent;
}

proc createCustomExtensionControl()
{
	attrControlGrp
		-label "Extension"
		-attribute defaultRenderGlobals.outFormatExt
		userExt;

	connectControl -index 1 userExt defaultRenderGlobals.outFormatExt;

	scriptJob 
		-parent userExt 
		-attributeChange "defaultRenderGlobals.outFormatControl" 
		"updateMayaSoftwareCustomExtensionControl";
}

global proc updateMayaSoftwareCustomExtensionControl()
{
	string $oldParent = `setParent -query`;

	setParentToCommonTab();

	// TODO: Find a better name for value1
	int $useImage = (`getAttr "defaultRenderGlobals.outFormatControl"` != 1);
	int $value1 = (`getAttr "defaultRenderGlobals.outFormatControl"` == 2);
	int $useExt = $useImage && $value1;

	attrControlGrp 
		-edit
		-enable $useExt
		userExt;

	setParent $oldParent;
}

proc enableMacCompressorbutton(int $imgFmt)
{
	if(`about -mac`) {
		// 22 is Quicktime (qt)
		button -e -enable ($imgFmt == 22) renderGlobalsCompression;
	}
}

proc createCompressorControlForMac(int $item)
{
	rowLayout -adjustableColumn true -nc 4 ;
	text -l "";
	button -l "Compression..." -width 80 -enable false -c "movieCompressor -softwareOptions" renderGlobalsCompression;
	text -l "";
	text -l "";
	setParent ..;
	
	enableMacCompressorbutton(`getAttr defaultRenderGlobals.imageFormat`);
}

global proc string createMayaImageFormatControl()
{
	string $currentRenderer = currentRenderer();
	if( ($currentRenderer == "mentalRay") || ($currentRenderer == "mental") )
		return createMRImageFormatControl();
	
	string $parent = `setParent -query`;

	// Delete the control if it already exists
	//
	string $fullPath = $parent + "|imageMenuMayaSW";
	if (`layout -exists $fullPath`) {
		deleteUI $fullPath;
	}

	optionMenuGrp 
		-label "Image Format" 
		-changeCommand "changeMayaSoftwareImageFormat"
		imageMenuMayaSW;

	int $isVector = 0;
	if( $currentRenderer == "mayaVector" )
		$isVector = 1;
		
	buildImageFormatsMenu($isVector, 1, 1, 1, 1);

	// connect the label, so we can change its color
	connectControl -index 1 imageMenuMayaSW defaultRenderGlobals.imageFormat;
	// connect the menu, so it will always match the attribute
	connectControl -index 2 imageMenuMayaSW defaultRenderGlobals.imageFormat;

	scriptJob 
		-parent $parent 
		-attributeChange 
			"defaultRenderGlobals.imageFormat" 
			"updateMayaSoftwareImageFormatControl";
			
	return "imageMenuMayaSW";
}

global proc updateMayaSoftwareImageFormatControl()
{
	string $currentRenderer = currentRenderer();
	if( ($currentRenderer == "mentalRay") || ($currentRenderer == "mental") )
		return;

	string $oldParent = `setParent -query`;

	setParentToCommonTab();

	int $imageNum = `getAttr "defaultRenderGlobals.imageFormat"`;
	string $key = `getAttr "defaultRenderGlobals.imfkey"`;
	string $items[] = `optionMenuGrp -q -itemListShort imageMenuMayaSW`;
	int $i = 0;
	
	int $found = 0;

	global string $imfPlugInKey[];
	for ($i=0; $i < size($items); $i++) {
		// Skip dividers, because there is not data associated
		if (`menuItem -q -divider $items[$i]`) continue;

		int $val = `menuItem -q -data $items[$i]`;
		if (($imageNum == 50) && ($val>=1000) && ($key == $imfPlugInKey[$val-1000])) {
			$found = 1;
			break;
		} else if ($val == $imageNum) {
			$found = 1;
			break;
		}
	}

	// could not find the corresponding image format. fall back to iff.
	if (!$found) {
		$imageNum = 7;						// Iff
		for ($i=0; $i < size($items); $i++) {
			int $val = `menuItem -q -data $items[$i]`;
			if ($val == 7) {
				$found = 1;
				break;
			}
		}
		// If Iff is not supported, pick the first format available.
		if (!$found) { $i = 0; $imageNum = `menuItem -q -data $items[$i]`; }

		setAttr defaultRenderGlobals.imageFormat $imageNum;
		updateMayaSoftwareImageFormatControl();
	}

	// Workaround for bug 233144:
	//		Somehow when the scriptJob executes this function on Mac,
	//		the parent has been incorrectly set
	//
	if( `layout -exists $oldParent` )
		setParent $oldParent;

	optionMenuGrp -edit -sl ($i+1) imageMenuMayaSW;
	enableMacCompressorbutton($imageNum);
}

// ************************************
// renderer name is hardcoded.
// this needs to be improved.
global proc updateMayaImageFormatControl()
{
	string $currentRenderer = currentRenderer();

	if( ($currentRenderer == "mentalRay") || ($currentRenderer == "mental") )
		updateMentalRayImageFormatControl();
	else
		updateMayaSoftwareImageFormatControl();	
}

global proc changeMayaSoftwareImageFormat()
{
//
//  Procedure Name:
//      changeImageFormat
//
//  Description:
//		This procedure is called when the user changes the type of 
//		image that will be written out.  It sets the internal 
//		representation and then updates the example to show the changes.
//
	string $oldParent = `setParent -query`;
	setParentToCommonTab();
	if (size(`optionMenuGrp -q -v imageMenuMayaSW`) == 0) {
		// Divider is selected. Its label (or value) is null.
		// Switch imageFormat to 7 (Maya IFF)
		//
		setAttr defaultRenderGlobals.imageFormat 7;
		setAttr defaultRenderGlobals.imfkey -type "string" "";
		updateMayaSoftwareImageFormatControl();
	}

	int $item = `optionMenuGrp -q -sl imageMenuMayaSW` - 1;
	
	setImageFormat();
   
	enableMacCompressorbutton(`getAttr defaultRenderGlobals.imageFormat`);
 
   
    // Check if the image format is IFF.
    //
    // Note: there are two IFF image types. One for 8 bit images
    // and one for 16 bit images. They both have an imgExt of iff.

    if (getImfImageType() != "iff") 
	{
        int $useBlur = `getAttr defaultRenderGlobals.motionBlur`;
        int $blur2d = (`getAttr defaultRenderGlobals.motionBlurType` == 0);
		int $keepMotionVector = (`getAttr defaultRenderGlobals.keepMotionVector` == 1);
        if ($useBlur && $blur2d && $keepMotionVector) 
		{
            warning
                ("Non-IFF image formats are not supported when writing"+
                 " 2D motion vectors; setting image format to IFF");

            // Set globals imageFormat to Maya IFF
            setAttr defaultRenderGlobals.imageFormat 7;
        }
    }

	int $multiframe = multiframeFormat(getImfImageType());

	if ($multiframe)
	{
		setAttr defaultRenderGlobals.animation 1;
	}

	// Update the batch render window if it exists.	
	if (`exists updateBatchRenderWindowTitle`) 
	{
		updateBatchRenderWindowTitle();
	}

	setParent $oldParent;
}

proc createCameraControl()
{
	//Note: not updating if changed elsewhere
	//
	optionMenuGrp 
		-label "Camera" 
		-changeCommand changeMayaSoftwareCamera 
		mayaSoftwareCameraMenu;
}

global proc updateMayaSoftwareCameraControl()
{
	string $oldParent = `setParent -query`;

	setParentToCommonTab();

	// This is a fix to get around the optionMenuGrp bug (#81337)
	string $fullName = `setParent "mayaSoftwareCameraMenu"`;
	string $menuName = ($fullName+"|OptionMenu");
	setParent -m $menuName;

	string $allCameras[] = `ls -cameras`;
	string $parents[];
	int    $i;
	int	   $numRenderable = 0;
	string $cmd;

	//
	// First remove any existing menuItems; we're gonna rebuild the menu
	// from scratch each time.

	int $numOldMenuItems = `optionMenuGrp -q -ni $fullName`;
	string	$oldMenuItems[] = `optionMenuGrp -q -ill $fullName`;

	for ($i = 0; $i < $numOldMenuItems; $i++) 
	{
		deleteUI $oldMenuItems[$i];
	}

	// Run through the list of all of the cameras and build a
	// optionMenu of them that the user uses to select the
	// renderable camera.
	//
	// First count how many renderable cameras exist
	//
	for ($i = 0; $i < size($allCameras); $i++) 
	{
		if (`getAttr ($allCameras[$i] + ".renderable")`) 
		{
			$numRenderable++;
		}
	}

	int $firstRenderable = 0;
	for ($i = 0; $i < size($allCameras); $i++) 
	{
		$parents = `listRelatives -path -parent $allCameras[$i]`;
		string $menuItem = `menuItem -label $parents[0]`;
		// Use the first renderable camera
		if (`getAttr ($allCameras[$i] + ".renderable")`) 
		{
			$firstRenderable++;
			if ($firstRenderable == 1) 
			{
				// Selected Camera -----------------------------------------
				optionMenuGrp -edit -sl ($i+1) $fullName;
			}
			if ($numRenderable > 1) 
			{
				string $camLabel = $parents[0] + " (Renderable)";
				menuItem -edit -label $camLabel $menuItem;
			}
		}
	}

	setParent $oldParent;
}

global proc changeMayaSoftwareCamera()
{
//
//  Procedure Name:
//      changeMayaSoftwareCamera
//
//  Description:
//		This procedure is called when the user changes the camera
//		that will be rendered.
//		It updates the controls for the new camera
//
	string $oldParent = `setParent -query`;
	setParentToCommonTab();

	//
	// First count how many renderable cameras exist
	//
	string $allCameras[] = `ls -cameras`;

	int $numRenderable = 0;

	for ($i = 0; $i < size($allCameras); $i++) 
	{
		if (`getAttr ($allCameras[$i] + ".renderable")`) 
		{
			$numRenderable++;
		}
	}

	int $camIndex = `optionMenuGrp -query -select mayaSoftwareCameraMenu` - 1;

	if ($numRenderable < 2) 
	{
		for ($i = 0; $i < size($allCameras); $i++) 
		{
			if ($i == $camIndex) 
			{
				setAttr ($allCameras[$i] + ".renderable") 1;
			}
			else 
			{
				setAttr ($allCameras[$i] + ".renderable") 0;
			}
		}
	}

	// Connect the channel controls to the new camera.
	//
	string $whichCamera = $allCameras[$camIndex];
	attrControlGrp -edit -attribute ($whichCamera + ".image") rgbChannel;
	attrControlGrp -edit -attribute ($whichCamera + ".mask") alphaChannel;
	attrControlGrp -edit -attribute ($whichCamera + ".depth") depthChannel;

	setParent $oldParent;
}

global proc updateMayaSoftwareFrameNumberControls()
{
	string $oldParent = `setParent -query`;
	setParentToCommonTab();

	int $useAnim 		= `getAttr "defaultRenderGlobals.animation"`;
	int $useCustomExt	= `getAttr "defaultRenderGlobals.modifyExtension"`;
	int $multiframe = multiframeFormat(getImfImageType());
	
	attrControlGrp 
		-edit
		-enable $useAnim
		startFrameCtrl;
	attrControlGrp 
		-edit
		-enable $useAnim
		endFrameCtrl;
	attrControlGrp 
		-edit
		-enable $useAnim
		byFrameStepCtrl;
	attrControlGrp 
		-edit
		-enable ($useAnim && !$multiframe)
		extensionPaddingCtrl;
	attrControlGrp
		-edit
		-enable ($useAnim && !$multiframe)
		modifyExtensionCtrl;
	attrControlGrp 
		-edit
		-enable ($useAnim && $useCustomExt && !$multiframe)
		startExtensionCtrl;
	attrControlGrp 
		-edit
		-enable ($useAnim && $useCustomExt && !$multiframe)
		byExtensionCtrl;

	setParent $oldParent;
}

proc createCommonImageFile() 
//
//  Procedure Name:
//      createCommonImageFile
//
//  Description:
//      Creates the UI in the "Image File Output" expand/collapse section.
//		This section is always created so is treated differently
//		then the sections created when the tab is expanded.
//
{
	string $parent = `setParent -query`;

	// Delete the control if it already exists
	//
	string $fullPath = $parent + "|imageFileOutputSW";
	if (`layout -exists $fullPath`) {
		deleteUI $fullPath;
	}

	setUITemplate -pushTemplate attributeEditorTemplate;

	global string $imgExt[];

	if (size($imgExt) == 0)
	{
		// If the file format array has not been initialized yet, do so.
		// This routine may be called in dynPaintMenus.mel during the
		// file save for PFX canvas images.
        //
		createImageFormats();
	}
	
	columnLayout -adjustableColumn true imageFileOutputSW;

		createFileNamePrefixControl();
		createFileNameFormatControl();
		
		formLayout baboForm;
		string $imageFormatControl = createMayaImageFormatControl();
		setParent ..;
		if(`about -mac`){
			int $item = `optionMenuGrp -q -sl $imageFormatControl` - 1; 
			createCompressorControlForMac($item);
		}
	
		separator;
	
		// Frame numbers ------------------------------------------------

		attrControlGrp 
			-attribute defaultRenderGlobals.startFrame 
			-label "Start Frame"
			-hideMapButton true
			startFrameCtrl;
		attrControlGrp 
			-attribute defaultRenderGlobals.endFrame 
			-label "End Frame"
			-hideMapButton true
			endFrameCtrl;
		attrControlGrp 
			-attribute defaultRenderGlobals.byFrameStep
			-label "By Frame"
			-hideMapButton true
			byFrameStepCtrl;
		attrControlGrp 
			-attribute defaultRenderGlobals.extensionPadding
			-label "Frame Padding"
			-hideMapButton true
			extensionPaddingCtrl;

		separator;

		// Cameras ------------------------------------------------

		createCameraControl();		
	    updateMayaSoftwareCameraControl();

		// Channels ------------------------------------------------

        //
		string $currentCamera = `optionMenuGrp -q -v mayaSoftwareCameraMenu`;
        //
        // Remove the substring " (Renderable)" from the string
        // $currentCamera if there is any.
        //
        $currentCamera = `substitute " .*" $currentCamera ""`;
		string $camShapes[] = `listRelatives -path -shapes -type camera $currentCamera`;
		$currentCamera = $camShapes[0];

		attrControlGrp
			-label "RGB Channel (Color)"
			-attribute ($currentCamera + ".image")
			rgbChannel;
		attrControlGrp
			-label "Alpha Channel (Mask)"
			-attribute ($currentCamera + ".mask")
			alphaChannel;
		attrControlGrp
			-label "Depth Channel (Z Depth)"
			-attribute ($currentCamera + ".depth")
			depthChannel;

		// Custom Extension ----------------------------------------

		frameLayout
			-label "Custom Filename Extension"
			-collapsable true
			-collapse true;

			columnLayout;

				createUseCustomExtensionControl();
				createCustomExtensionControl();

			setParent ..;
		setParent ..;

		// Renumber ------------------------------------------------
        
		frameLayout
			-label "Renumber Frames"
			-collapsable true
			-collapse true;

			columnLayout;

				attrControlGrp 
					-attribute defaultRenderGlobals.modifyExtension
					-changeCommand "updateMayaSoftwareFrameNumberControls"
					-label "Renumber Frames Using:"
					modifyExtensionCtrl;
				attrControlGrp 
					-attribute defaultRenderGlobals.startExtension
					-enable (`getAttr defaultRenderGlobals.modifyExtension`)
					-hideMapButton true
					-label "Start Number"
					startExtensionCtrl;
				attrControlGrp 
					-attribute defaultRenderGlobals.byExtension
					-enable (`getAttr defaultRenderGlobals.modifyExtension`)
					-hideMapButton true
					-label "By Frame"
					byExtensionCtrl;

			setParent ..;
		setParent ..;

    setParent $parent;
	setUITemplate -popTemplate;

	// Perform an initial update of the UI created above, so that controls
	// which are not directly connected to attributes are properly initialized.
	//
	updateMayaSoftwareFileNamePrefixControl();
	updateMayaSoftwareFileNameFormatControl();
	updateMayaImageFormatControl();
	updateMayaSoftwareUseCustomExtensionControl();
	updateMayaSoftwareCustomExtensionControl();
}

// ----------------------------------------------------------------------------
// Code to create and update the Resolution frame 
//

global proc createCommonResolution()
//
//  Procedure Name:
//      createCommonResolution
//
//  Description:
//      Creates the UI in the "Resolution" expand/collapse section.
//
{
	//
	// Make sure the list of predefined resolutions has been read in.
	//
	global string   $gImageFormatData[];
	global string   $gUserImageFormatData[];

	if (size($gImageFormatData) == 0) 
	{
		eval("source imageFormats");
	}

	global string	$gResolutionUnitsNames[];
	global string	$gMeasurementUnitsNames[];

	if (size($gResolutionUnitsNames) == 0)
	{
		eval("source resolutionFormats");
	}

	int $isMayaEvalVersion = `about -ev`;
	global string   $gPLEImageFormatData[];
	if ($isMayaEvalVersion) 
	{
		$gImageFormatData = $gPLEImageFormatData;
	}

	if (exists("userImageFormats.mel") && size($gUserImageFormatData) == 0) 
	{
		// Yes, we need the eval here, to avoid doing the source
		// until we know whether the file actually exists
		eval("source userImageFormats");
	}

	setUITemplate -pushTemplate attributeEditorTemplate;

	string $parent = `setParent -q`;
	// If the UI is created already then just update the attribute values.
	if (`columnLayout -exists ($parent+"|rgResolutionLayout")`) 
	{
		updateMayaSoftwareResolution();
		return;
	}

	columnLayout -adjustableColumn true rgResolutionLayout;
		int		$resItem;
		int		$numResolutionPresets = size($gImageFormatData);
		int		$numUserResolutionPresets = size($gUserImageFormatData);
		string  $allResNodes[] = `ls -type resolution`;
		int		$numResolutionNodePresets = size($allResNodes) - 1;
		int		$numTokens;
		string	$tokens[];
		string  $niceName;
		global int	$gImageFormatDividerPosition;

		optionMenuGrp 
			-label "Presets" 
			-changeCommand "changeMayaSoftwareResolution()" 
			resolutionMenu;

			menuItem -label "Custom";
			for ($resItem = 0; $resItem < $numResolutionPresets; $resItem++) 
			{
				if( $resItem == $gImageFormatDividerPosition ){
					menuItem -label "---------------------" -enable false;
				}else{
					string $item = $gImageFormatData[$resItem];
					$numTokens = tokenize($item, $tokens);

					// Change any underscore into a space;
					// some names may have up to 2 underscores in them,
					// so we do this twice.
					//
					$niceName = `substitute "_" $tokens[0] " "`;
					$niceName = `substitute "_" $niceName " "`;
					menuItem -label $niceName;
				}
			}
			for ($resItem = 0; $resItem < $numUserResolutionPresets; $resItem++)
			{
				string $item = $gUserImageFormatData[$resItem];
				$numTokens = tokenize($item, $tokens);

				// Change any underscore into a space;
				// some names may have up to 2 underscores in them,
				// so we do this twice.
				//
				$niceName = `substitute "_" $tokens[0] " "`;
				$niceName = `substitute "_" $niceName " "`;
				menuItem -label $niceName;
			}
			for ($resItem = 0; $resItem < $numResolutionNodePresets; $resItem++)
			{
				menuItem -label $allResNodes[$resItem + 1];
			}

		separator;
		
		checkBoxGrp -numberOfCheckBoxes 1
			-label ""
			-label1 "Maintain Width/Height Ratio"
			-changeCommand "setAttr defaultResolution.aspectLock #1"
			aspectLockCheck;
		connectControl -index 2 aspectLockCheck defaultResolution.aspectLock;

		radioButtonGrp -numberOfRadioButtons 2
			-label "Maintain Ratio"
			-label1 "Pixel Aspect" 
			-label2 "Device Aspect" 
			-on1 "setAttr defaultResolution.lockDeviceAspectRatio 0"
			-on2 "setAttr defaultResolution.lockDeviceAspectRatio 1"
			-data1 0
			-data2 1
			ratioLockRadio;
		connectControl -index 1 ratioLockRadio defaultResolution.lockDeviceAspectRatio;

		floatFieldGrp -label "Width" 
			-changeCommand "changeMayaSoftwareAspectLockWidth"
			mayaSoftwareResWidth;
		connectControl -index 1 mayaSoftwareResWidth defaultResolution.width;

		floatFieldGrp -label "Height" 
			-changeCommand "changeMayaSoftwareAspectLockHeight"
			mayaSoftwareResHeight;
		connectControl -index 1 mayaSoftwareResHeight defaultResolution.height;

		optionMenuGrp
			-label "Size Units" 
			-changeCommand "updateMayaSoftwareResolution" 
			sizeUnitsMenu;

		// Construct all menu items
		int $sizeUnit;
		for( $sizeUnit=0 ; $sizeUnit<size($gMeasurementUnitsNames) ; $sizeUnit++ ){
			menuItem -label $gMeasurementUnitsNames[$sizeUnit] -data $sizeUnit;
		}
		// connect the label, so we can change its color
		connectControl -index 1 sizeUnitsMenu defaultResolution.imageSizeUnits;
		// connect the menu, so it will always match the attribute
		connectControl -index 2 sizeUnitsMenu defaultResolution.imageSizeUnits;

		separator -style none -h 5;

		floatFieldGrp -label "Resolution"
			-changeCommand "changeMayaSoftwareRes"
			mayaSoftwareRes;
		connectControl -index 1 mayaSoftwareRes defaultResolution.dotsPerInch;

		optionMenuGrp 
			-label "Resolution Units" 
			-changeCommand "updateMayaSoftwareResolution"
			resUnitsMenu;

		// Construct all menu items
		int $resUnit;
		for( $resUnit=0 ; $resUnit<size($gResolutionUnitsNames) ; $resUnit++ ){
			menuItem -label $gResolutionUnitsNames[$resUnit] -data $resUnit;
		}
		// connect the label, so we can change its color
		connectControl -index 1 resUnitsMenu defaultResolution.pixelDensityUnits;
		// connect the menu, so it will always match the attribute
		connectControl -index 2 resUnitsMenu defaultResolution.pixelDensityUnits;

		separator;

		floatFieldGrp -label "Device Aspect Ratio"  
			-changeCommand "updateMayaSoftwareDeviceAspectRatio"
			resRatio;
		// connect the label, so we can change its color
		connectControl -index 1 resRatio defaultResolution.deviceAspectRatio;
		// connect the menu, so it will always match the attribute
		connectControl -index 2 resRatio defaultResolution.deviceAspectRatio;

		floatFieldGrp -label "Pixel Aspect Ratio"  
			-changeCommand "updateMayaSoftwarePixelAspectRatio" 
			pixRatio;
		// connect the label, so we can change its color
		connectControl -index 1 pixRatio defaultResolution.pixelAspect;
		// connect the menu, so it will always match the attribute
		connectControl -index 2 pixRatio defaultResolution.pixelAspect;

    setParent ..;
	setUITemplate -popTemplate;

	// Make sure the values are right
	updateMayaSoftwareResolution();

	// Set up script jobs for those attributes which require updating of
	// multiple controls.
	// This is especially important when a user changes render layers. 
	//
	string $attrArray[];
	$attrArray[size($attrArray)] = "defaultResolution.width";
	$attrArray[size($attrArray)] = "defaultResolution.height";
	$attrArray[size($attrArray)] = "defaultResolution.dotsPerInch";
	$attrArray[size($attrArray)] = "defaultResolution.imageSizeUnits";
	$attrArray[size($attrArray)] = "defaultResolution.pixelDensityUnits";

	int $i;

	for ($i = 0; $i < size($attrArray); $i++)
	{
		scriptJob
			-attributeChange 
				$attrArray[$i]
				updateMayaSoftwareResolution
			-parent `setParent -query`;
	}
}

global proc changeMayaSoftwareRes()
//
//	Description:
//		Called when the resolution field is changed.
//		Updates the corresponding attribute, converting to DPI.
//
{
	string $oldParent = `setParent -query`;
    setParentToCommonTab();

	global string $gResolutionUnitsNames[];
	float $oldDPI = `getAttr defaultResolution.dotsPerInch`;
	float $value = `floatFieldGrp -q -v1 mayaSoftwareRes`;

	// Convert from the current resolution units to DPI
	int $resUnits = `getAttr defaultResolution.pixelDensityUnits`;
	float $newDPI = convertResolutionMeasurement(
		$value,
		$gResolutionUnitsNames[$resUnits],
		"pixels/inch"
		);

	// Check that value is within value range
	if( $newDPI < 1.0 ){
		warning "Resolution (DPI) must be at least 1.0 pixels/inch";
		$newDPI = 1.0;
	}

	int $oldWidth = `getAttr defaultResolution.width`;
	int $newWidth = $oldWidth;
	int $oldHeight = `getAttr defaultResolution.height`;
	int $newHeight = $oldHeight;

	// Change pixel width/height only if the image size units are not
	// currently set as pixels
	//
	int $sizeUnits = `getAttr defaultResolution.imageSizeUnits`;
	if( $sizeUnits != 0 ){ // 0 corresponds to pixels
		$newWidth = `floor( $oldWidth * $newDPI/$oldDPI + 0.5 )`;
		$newHeight = `floor( $oldHeight * $newDPI/$oldDPI + 0.5 )`;
	}

	// Account for version restrictions and bounds
	//
	int $isMayaEvalVersion = `about -ev`;
	int $kPLEMaxX = 1024;
	int $kPLEMaxY =  768;

	if ($isMayaEvalVersion)
	{
		// Check width
		if ($newWidth > $kPLEMaxX)
		{
			warning("Requested DPI cannot be achieved because image resolution is limited to "+$kPLEMaxX+"x"+$kPLEMaxY+" pixels for the Maya Personal Learning Edition");
			$newWidth = $kPLEMaxX;
			// Adjust DPI to maintain constant document size
			$newDPI = $oldDPI * $newWidth/$oldWidth;
			// Adjust height to maintain correct ratio
			$newHeight = $oldHeight * $newWidth/$oldWidth;
		}
		// Check height
		if ($newHeight > $kPLEMaxY)
		{
			warning("Requested DPI cannot be achieved because image resolution is limited to "+$kPLEMaxX+"x"+$kPLEMaxY+" pixels for the Maya Personal Learning Edition");
			$newHeight = $kPLEMaxY;
			// Adjust DPI to maintain constant document size
			$newDPI = $oldDPI * $newHeight/$oldHeight;
			// Adjust width to maintain correct ratio
			$newWidth = $oldWidth * $newHeight/$oldHeight;
		}
	}
	if ($newWidth < 2)
	{
		warning "Width must be at least 2 pixels";
		$newWidth = 2;
	}
	if ($newHeight < 2)
	{
		warning "Height must be at least 2 pixels";
		$newHeight = 2;
	}

	// All attributes should now be correct
	setAttr defaultResolution.dotsPerInch $newDPI;
	setAttr defaultResolution.width $newWidth;
	setAttr defaultResolution.height $newHeight;

	// Update the values, will correct any invalid entries
	updateMayaSoftwareResolution();

	setParent $oldParent;
}

global proc updateMayaSoftwareResolution()
//
//  Procedure Name:
//      updateMayaSoftwareResolution
//
//  Description:
//      Gets the real values from the nodes and sets the UI based
//		on these values.  This procedure updates all of the resolution
//		values.
//
{
	string $oldParent = `setParent -query`;
	setParentToCommonTab();

	int $width = `getAttr defaultResolution.width`;
	int $height = `getAttr defaultResolution.height`;
	float $aspect = `getAttr defaultResolution.deviceAspectRatio`;
	float $dpi = `getAttr defaultResolution.dotsPerInch`;
	int $resItem;
	int $whichRes = 1; // use "Custom" if no match is found
	string $allResNodes[] = `ls -type resolution`;

	global string   $gImageFormatData[];
	global string   $gUserImageFormatData[];
	global float $gDefaultDpi;
	int		$numResolutionPresets = size($gImageFormatData);
	int		$numUserResolutionPresets = size($gUserImageFormatData);
	int		$numResolutionNodePresets = size($allResNodes) - 1;
	int		$resWidth;
	int		$resHeight;
	float	$resAspect;
	float	$resDpi;
	int		$numTokens;
	string	$tokens[];

	for ($resItem = 0; $resItem < $numResolutionPresets; $resItem++) 
	{
		string $item = $gImageFormatData[$resItem];
		$numTokens = tokenize($item, $tokens);
		if ($numTokens == 5) 
		{
			$resWidth = $tokens[1];
			$resHeight = $tokens[2];
			$resAspect = $tokens[3];
			$resDpi = $tokens[4];

			// Check all values, including DPI. If the DPI in the array is 0
			// (i.e. unspecified), then any dpi is considered a match.
			if ($width == $resWidth && $height == $resHeight
					&& abs($aspect - $resAspect) < 0.001
					&& ($resDpi==0 || abs($dpi - $resDpi) < 0.001) )
			{
				// We add _2_ to $resItem below: 1 because we're
				// skipping the first item (Custom) in the list, and 1
				// because the optionMenu items are numbered starting at 1,
				// but our list in $gImageFormatData is indexed starting at 0.
				$whichRes = $resItem + 2;
				break;
			}
		} 
		else 
		{
			warning(
				"Found invalid image format description: \""
				+ $item 
				+ "\" in imageFormats.mel");
		}
	}

	// If no match was found in the built-in resolutions,
	// check out the user-defined ones
	//
	if ($whichRes == 1) 
	{
		for ($resItem = 0; $resItem < $numUserResolutionPresets; $resItem++) 
		{
			string $item = $gUserImageFormatData[$resItem];
			$numTokens = tokenize($item, $tokens);

			// User may or may not have specified a resolution.
			// Ensure compatibility.
			//
			if ($numTokens == 4 || $numTokens == 5) 
			{
				$resWidth = $tokens[1];
				$resHeight = $tokens[2];
				$resAspect = $tokens[3];
				if( $numTokens == 5 ){
					$resDpi = $tokens[4];
				}else{
					$resDpi = $gDefaultDpi;
				}

				if ($width == $resWidth && $height == $resHeight
						&& abs($aspect - $resAspect) < 0.001
						&& ($resDpi==0 || abs($dpi - $resDpi) < 0.001) )
				{
					$whichRes = $numResolutionPresets + $resItem + 2;
					break;
				}
			} 
			else 
			{
				warning(
					"Found invalid image format description: \""
					+ $item 
					+ "\" in userImageFormats.mel");
			}
		}
	}

	// If no match was found in the user-defined resolutions,
	// see if there are any 'extra' resolution nodes in the scene.
	//
	if ($whichRes == 1) 
	{
		for ($resItem = 0; $resItem < $numResolutionNodePresets; $resItem++) 
		{
			// We assume the 0th item in the list of resolution nodes is
			// the default one, which is created implicitly...
			//
			string $resNodeName = $allResNodes[$resItem + 1];

			$resWidth = `getAttr ($resNodeName + ".width")`;
			$resHeight = `getAttr ($resNodeName + ".height")`;
			$resAspect = `getAttr ($resNodeName + ".deviceAspectRatio")`;

			if ($width == $resWidth && $height == $resHeight
					&& abs($aspect - $resAspect) < 0.001) 
			{
				// We add _2_ to $resItem below: 1 because we're
				// skipping the first item (Custom) in the list, and 1
				// because the optionMenu items are numbered starting at 1,
				// but our list in $gImageFormatData is indexed starting at 0.
				//
				$whichRes = $numResolutionPresets
							+ $numUserResolutionPresets + $resItem + 2;
				break;
			}
		}
	}
	optionMenuGrp -edit -sl $whichRes resolutionMenu;

	checkBoxGrp -edit -v1 `getAttr defaultResolution.aspectLock` aspectLockCheck;
	floatFieldGrp -edit -v1 $aspect resRatio;
	adjustMayaSoftwarePixelAspect "defaultResolution";
	setAttr defaultResolution.pixelAspect `floatFieldGrp -q -v1 pixRatio`;
	radioButtonGrp -edit 
		-select (`getAttr defaultResolution.lockDeviceAspectRatio`+1) 
		ratioLockRadio;

	//
	// Update the UI controls for image size and resolution
	//

	global string $gMeasurementUnitsNames[];
	global string $gResolutionUnitsNames[];
	int $sizeUnits = `getAttr defaultResolution.imageSizeUnits`;
	int $resUnits = `getAttr defaultResolution.pixelDensityUnits`;

	// Update width and height fields
	float $docWidth = (float) $width;
	float $docHeight = (float) $height;
	int $precision = 0; // To ensure pixel values are displayed without decimals
	if( $sizeUnits != 0 ){
		// Convert from pixels to the correct measurement units
		$docWidth = convertMeasurement(
			convertPixelsToInches( $width, $dpi ),
			"inches",
			$gMeasurementUnitsNames[$sizeUnits]
			);
		$docHeight = convertMeasurement(
			convertPixelsToInches( $height, $dpi ),
			"inches",
			$gMeasurementUnitsNames[$sizeUnits]
			);
		$precision = 3;
	}
	floatFieldGrp -edit -precision $precision -v1 $docWidth mayaSoftwareResWidth;
	floatFieldGrp -edit -precision $precision -v1 $docHeight mayaSoftwareResHeight;

	// Update resolution field
	// Convert from DPI to the correct resolution units
	float $res = convertResolutionMeasurement(
		$dpi,
		"pixels/inch",
		$gResolutionUnitsNames[$resUnits]
		);
	floatFieldGrp -edit -precision 3 -v1 $res mayaSoftwareRes;

	// "Size Units" and "Resolution Units" fields automatically update
	// because they are attached to a harness

	setParent $oldParent;
}

global proc changeMayaSoftwareResolution()
//
//  Procedure Name:
//      changeResolution
//
//  Description:
//		This procedure is called when the user selects a different
//		resolution.  It sets the internal representation
//		and then updates the example to show the changes.
//
{
	string $oldParent = `setParent -query`;
	setParentToCommonTab();

	global string   $gImageFormatData[];
	global string   $gUserImageFormatData[];
	global float	$gDefaultDpi;
	
	// We are suppose to get proper image formats for PLE.
	int $isMayaEvalVersion = `about -ev`;
	if ($isMayaEvalVersion) 
	{
		global string   $gPLEImageFormatData[];
		$gImageFormatData = $gPLEImageFormatData;
	}
	int		$numResolutionPresets = size($gImageFormatData);
	int		$numUserResolutionPresets = size($gUserImageFormatData);
	string $allResNodes[] = `ls -type resolution`;
	int		$numResolutionNodePresets = size($allResNodes) - 1;
	string	$tokens[];
	int		$resItem = `optionMenuGrp -q -sl resolutionMenu`; 
	int		$resWidth;
	int		$resHeight;
	float	$resAspect;
	float	$resDpi=0; // signals preset doesn't contain dpi info
	string	$item;

	// Item #1 is Custom, which doesn't change the fields
	// We subtract _2_ from $resItem below: 1 because we're
	// skipping the first item (Custom) in the list, and 1
	// because the optionMenu items are numbered starting at 1,
	// but our list in $gImageFormatData is indexed starting at 0.
	//
	if ($resItem > 1) 
	{
		if ($resItem > ($numResolutionPresets + 1)) 
		{
			if ($resItem
					> ($numResolutionPresets + $numUserResolutionPresets + 1)) 
			{
				// It's one of the user-defined resolution nodes' presets
				string $resNodeName = $allResNodes[$resItem
												- $numResolutionPresets
												- $numUserResolutionPresets
												- 1];
				$resWidth = `getAttr ($resNodeName + ".width")`;
				$resHeight = `getAttr ($resNodeName + ".height")`;
				$resAspect = `getAttr ($resNodeName + ".deviceAspectRatio")`;
			} 
			else 
			{
				// It's one of the user-defined resolution presets
				$item = $gUserImageFormatData[$resItem
					- $numResolutionPresets - 2];
				int		$numTokens = tokenize($item, $tokens);
				$resWidth = $tokens[1];
				$resHeight = $tokens[2];
				$resAspect = $tokens[3];
				if( $numTokens == 5 ){ // user has included the dpi field
					$resDpi = $tokens[4];
				}else{
					$resDpi = $gDefaultDpi; // default dpi
				}
			}
		} 
		else 
		{
			// It's one of the built-in resolution presets
			$item = $gImageFormatData[$resItem - 2];
			int		$numTokens = tokenize($item, $tokens);
			$resWidth = $tokens[1];
			$resHeight = $tokens[2];
			$resAspect = $tokens[3];
			$resDpi = $tokens[4];
		}
		setAttr "defaultResolution.width" $resWidth;
		setAttr "defaultResolution.height" $resHeight;
		setAttr "defaultResolution.deviceAspectRatio" $resAspect;
		setAttr "defaultResolution.lockDeviceAspectRatio" 0;
		float $pixelAspect = ((float)$resHeight)/((float)$resWidth)*$resAspect;
		setAttr "defaultResolution.pixelAspect" $pixelAspect;

		// Set the dpi if it's non-zero
		if( $resDpi != 0 ){
			setAttr "defaultResolution.dotsPerInch" $resDpi;
		}

		// Set the proper field ordering if PAL or NTSC.
		if (`getAttr defaultResolution.height` == 576) // PAL
		{
			setAttr "defaultResolution.oddFieldFirst" 0;
			if (`columnLayout -exists rgFieldLayout`)
			{
				if (`exists updateFieldOptions`)
				{
					updateFieldOptions();
				}
			}
		} 
		else if (`getAttr defaultResolution.height` == 486) // NTSC
		{
			setAttr "defaultResolution.oddFieldFirst" 1;
			if (`columnLayout -exists rgFieldLayout`) 
			{
				if (`exists updateFieldOptions`)
				{
					updateFieldOptions();
				}
			}
		}
	}

	updateMayaSoftwareResolution();

	setParent $oldParent;
}

// This is called when the resolution changes. Update the pixel or the
// device aspect ration as necessary.
proc updatePixelDeviceRatios(string $nodeName)
{
	float $aspect = (float)`getAttr ($nodeName + ".width")` /
		(float)`getAttr ($nodeName + ".height")`;

	if (`getAttr ($nodeName + ".lockDeviceAspectRatio")` == 0) 
	{
		$aspect = $aspect * `getAttr ($nodeName + ".pixelAspect")`;
		setAttr ($nodeName + ".deviceAspectRatio") $aspect;
	}
	else
	{
		$aspect = `getAttr ($nodeName + ".deviceAspectRatio")` / $aspect;
		setAttr ($nodeName + ".pixelAspect") $aspect;
	}
}

global proc checkMayaSoftwareAspectLockWidth(string $nodeName)
{
	float $deviceAspect;

	if (`getAttr ($nodeName + ".aspectLock")`) 
	{
		float $value = `getAttr ($nodeName + ".width")`;
		float $aspect = `getAttr ($nodeName + ".pixelAspect")`;
		$aspect /= `getAttr ($nodeName + ".deviceAspectRatio")`;

		int $rez = ($aspect * $value);

		int $isMayaEvalVersion = `about -ev`;
		if ($isMayaEvalVersion)
		{
			int $kPLEMaxY =  768;
			int $kPLEMaxX = 1024;
			if ($rez > $kPLEMaxY) {
				warning("Image resolution is limited to "+$kPLEMaxX+"x"+$kPLEMaxY+" pixels for the Maya Personal Learning Edition");
				$rez = $kPLEMaxY;
			}
		}
		setAttr ($nodeName + ".height") $rez;
	}

	updatePixelDeviceRatios($nodeName);
}

global proc checkMayaSoftwareAspectLockHeight(string $nodeName)
{
	float $deviceAspect;

	if (`getAttr ($nodeName + ".aspectLock")`)
	{
		float $value = `getAttr ($nodeName + ".height")`;
		float $aspect = `getAttr ($nodeName + ".pixelAspect")`;
		$aspect /= `getAttr ($nodeName + ".deviceAspectRatio")`;
		
		int $rez = ($value/$aspect);

		int $isMayaEvalVersion = `about -ev`;
		if ($isMayaEvalVersion)
		{
			int $kPLEMaxY =  768;
			int $kPLEMaxX = 1024;
			if ($rez > $kPLEMaxX) {
				warning("Image resolution is limited to "+$kPLEMaxX+"x"+$kPLEMaxY+" pixels for the Maya Personal Learning Edition");
				$rez = $kPLEMaxX;
			}
		}

		setAttr ($nodeName + ".width") $rez;
	}

	updatePixelDeviceRatios($nodeName);
}

global proc changeMayaSoftwareAspectLockWidth()
//
//  Procedure Name:
//      changeMayaSoftwareAspectLockWidth
//
//  Description:
//		This procedure is called when the user changes the
//		resolution width.  It sets the internal representation
//		then looks at the ratio lock etc and changes any other 
//		values that rely on it. 
//
{
	string $oldParent = `setParent -query`;
	setParentToCommonTab();

	float $widthValue = `floatFieldGrp -q -v1 mayaSoftwareResWidth`;
	int $requestedWidth;

	global string $gMeasurementUnitsNames[];
	float $dpi = `getAttr defaultResolution.dotsPerInch`;
	int $sizeUnits = `getAttr defaultResolution.imageSizeUnits`;

	if( $sizeUnits != 0 ){
		// Convert the obtained value to inches, then to pixels
		$requestedWidth = convertInchesToPixels(
			convertMeasurement( $widthValue, $gMeasurementUnitsNames[$sizeUnits], "inches" ),
			$dpi
			);
	}else{ // the width value is in pixels, so no need to convert
		$requestedWidth = $widthValue;
	}

	int $isMayaEvalVersion = `about -ev`;
	if ($isMayaEvalVersion)
	{
		int $kPLEMaxX = 1024;
		int $kPLEMaxY =  768;
		if ($requestedWidth > $kPLEMaxX)
		{
			warning("Image resolution is limited to "+$kPLEMaxX+"x"+$kPLEMaxY+" pixels for the Maya Personal Learning Edition");
			$requestedWidth = $kPLEMaxX;
		}
	}

	if ($requestedWidth < 2)
	{
		warning "Width must be at least 2 pixels";
		$requestedWidth = 2;
	}

	setAttr defaultResolution.width $requestedWidth;
	optionMenuGrp -edit -sl 1 resolutionMenu;
	checkMayaSoftwareAspectLockWidth "defaultResolution";

	// Update the values
	updateMayaSoftwareResolution();

	setParent $oldParent;
}

global proc changeMayaSoftwareAspectLockHeight()
//
//  Procedure Name:
//      changeMayaSoftwareAspectLockHeight
//
//  Description:
//		This procedure is called when the user changes the
//		resolution width.  It sets the internal representation
//		then looks at the ratio lock etc and changes any other 
//		values that rely on it. 
//
{
	string $oldParent = `setParent -query`;
	setParentToCommonTab();

	float $heightValue = `floatFieldGrp -q -v1 mayaSoftwareResHeight`;
	int $requestedHeight;
	global string $gMeasurementUnitsNames[];
	float $dpi = `getAttr defaultResolution.dotsPerInch`;
	int $sizeUnits = `getAttr defaultResolution.imageSizeUnits`;

	if( $sizeUnits != 0 ){
		// Convert the obtained value to inches, then to pixels
		$requestedHeight = convertInchesToPixels(
			convertMeasurement( $heightValue, $gMeasurementUnitsNames[$sizeUnits], "inches" ),
			$dpi
			);
	}else{ // the width value is in pixels, so no need to convert
		$requestedHeight = $heightValue;
	}

	int $isMayaEvalVersion = `about -ev`;
	if ($isMayaEvalVersion)
	{
		int $kPLEMaxX = 1024;
		int $kPLEMaxY =  768;
		if ($requestedHeight > $kPLEMaxY)
		{
			warning("Image resolution is limited to "+$kPLEMaxX+"x"+$kPLEMaxY+" pixels for the Maya Personal Learning Edition");
			$requestedHeight = $kPLEMaxY;
		}
	}

	if ($requestedHeight < 2)
	{
		warning "Height must be at least 2 pixels";
		$requestedHeight = 2;
	}

	setAttr defaultResolution.height $requestedHeight;
	optionMenuGrp -edit -sl 1 resolutionMenu;
	checkMayaSoftwareAspectLockHeight "defaultResolution";

    // Set the proper field ordering if PAL or NTSC.
    if (`getAttr defaultResolution.height` == 576) // PAL
	{
        setAttr "defaultResolution.oddFieldFirst" 0;
        if (`columnLayout -exists rgFieldLayout`) 
		{
			if (`exists updateFieldOptions`)
			{
				updateFieldOptions();
			}
		}
    }
	else if (`getAttr defaultResolution.height` == 486) // NTSC
	{
        setAttr "defaultResolution.oddFieldFirst" 1;
        if (`columnLayout -exists rgFieldLayout`)
		{
			if (`exists updateFieldOptions`)
			{
				updateFieldOptions();
			}
		}
    }

	// Update the values
	updateMayaSoftwareResolution();

	setParent $oldParent;
}


global proc adjustMayaSoftwarePixelAspect(string $nodeName)
{
	string $oldParent = `setParent -query`;
	setParentToCommonTab();

    string $aspectAttr = $nodeName + ".deviceAspectRatio";
    string $widthAttr = $nodeName + ".width";
    string $heightAttr = $nodeName + ".height";
    float  $pixelAspect = (float) `getAttr $widthAttr`
                          / (float) `getAttr $heightAttr`;
    $pixelAspect = `getAttr $aspectAttr` / $pixelAspect;
    floatFieldGrp -e -v1 $pixelAspect pixRatio;

	setParent $oldParent;
}

global proc adjustMayaSoftwareDeviceAspect(string $nodeName)
{
	string $oldParent = `setParent -query`;
	setParentToCommonTab();

	string $devAspectAttr = $nodeName + ".deviceAspectRatio";
	string $widthAttr = $nodeName + ".width";
	string $heightAttr = $nodeName + ".height";

    float $pixelAspect = `floatFieldGrp -q -v1 pixRatio`;
    float $aspect = (float) `getAttr $widthAttr`
					/ (float) `getAttr $heightAttr`;
    $aspect = $pixelAspect * $aspect;
    setAttr $devAspectAttr $aspect;
	floatFieldGrp -edit -v1 $aspect resRatio;

	setParent $oldParent;
}

global proc updateMayaSoftwarePixelAspectRatio()
{
	string $oldParent = `setParent -query`;
	setParentToCommonTab();

	setAttr defaultResolution.pixelAspect `floatFieldGrp -q -v1 pixRatio`;
	adjustMayaSoftwareDeviceAspect "defaultResolution";
	updateMayaSoftwareResolution();

	setParent $oldParent;
}

global proc updateMayaSoftwareDeviceAspectRatio()
{
	string $oldParent = `setParent -query`;
	setParentToCommonTab();

	setAttr defaultResolution.deviceAspectRatio 
		`floatFieldGrp -q -v1 resRatio`;
	adjustMayaSoftwarePixelAspect "defaultResolution";
	updateMayaSoftwareResolution();

	setParent $oldParent;
}

// ----------------------------------------------------------------------------
// Code to update pre/post layer/frame mel callbacks
//

global proc changeMayaMelCallbacks(string $control, string $attr)
{
	string $oldParent = `setParent -query`;
	setParentToCommonTab();

	string $val = `textFieldGrp -query -text $control`;
	setAttr $attr -type "string" $val;

	setParent $oldParent;
}

global proc updateMayaMelCallbacks()
{
	string $oldParent = `setParent -query`;
	setParentToCommonTab();

	textFieldGrp -edit -text `getAttr defaultRenderGlobals.preRenderLayerMel` preRenderLayerMelSwGrp;
	textFieldGrp -edit -text `getAttr defaultRenderGlobals.postRenderLayerMel` postRenderLayerMelSwGrp;
	textFieldGrp -edit -text `getAttr defaultRenderGlobals.preRenderMel` preRenderMelSwGrp;
	textFieldGrp -edit -text `getAttr defaultRenderGlobals.postRenderMel` postRenderMelSwGrp;

	setParent $oldParent;
}

// ----------------------------------------------------------------------------
// Code to create and update the Render Options frame 
//

proc createCommonRenderOptions()
{
	string $parent = `setParent -query`;

	setUITemplate -pushTemplate attributeEditorTemplate;

	
	columnLayout -adjustableColumn true;
	
		attrControlGrp 
			-attribute "defaultRenderGlobals.enableDefaultLight";
		attrControlGrp 
			-attribute defaultRenderGlobals.preMel 
			-label "Pre Render MEL"
			-preventOverride true
			preMelSwGrp;
		attrControlGrp 
			-attribute defaultRenderGlobals.postMel 
			-label "Post Render MEL"
			-preventOverride true
			postMelSwGrp;
			
		textFieldGrp
			-label "Pre Render Layer MEL"
			-changeCommand ("changeMayaMelCallbacks(\"preRenderLayerMelSwGrp\", \"defaultRenderGlobals.preRenderLayerMel\")")
			preRenderLayerMelSwGrp;
				
		textFieldGrp 
			-label "Post Render Layer MEL"
			-changeCommand ("changeMayaMelCallbacks(\"postRenderLayerMelSwGrp\", \"defaultRenderGlobals.postRenderLayerMel\")")
			postRenderLayerMelSwGrp;			            
				
		textFieldGrp 
			-label "Pre Render Frame MEL"
			-changeCommand ("changeMayaMelCallbacks(\"preRenderMelSwGrp\", \"defaultRenderGlobals.preRenderMel\")")
			preRenderMelSwGrp;
			
		textFieldGrp 
			-label "Post Render Frame MEL"
			-changeCommand ("changeMayaMelCallbacks(\"postRenderMelSwGrp\", \"defaultRenderGlobals.postRenderMel\")")
			postRenderMelSwGrp;
			
		connectControl -index 1 preRenderLayerMelSwGrp defaultRenderGlobals.preRenderLayerMel;	
		connectControl -index 1 postRenderLayerMelSwGrp defaultRenderGlobals.postRenderLayerMel;
		connectControl -index 1 preRenderMelSwGrp defaultRenderGlobals.preRenderMel;	
		connectControl -index 1 postRenderMelSwGrp defaultRenderGlobals.postRenderMel;		

		if (`about -evalVersion`)
		{
			attrControlGrp -e -enable false preMelSwGrp;
			attrControlGrp -e -enable false postMelSwGrp;
			textFieldGrp -e -enable false preRenderLayerMelSwGrp;
			textFieldGrp -e -enable false postRenderLayerMelSwGrp;
			textFieldGrp -e -enable false preRenderMelSwGrp;
			textFieldGrp -e -enable false postRenderMelSwGrp;
		}
			
		updateMayaMelCallbacks();

		// Set up script jobs for those attributes which require updating of
		// multiple controls.
		// This is especially important when a user changes render layers. 
		//
		string $attrArray[];	clear($attrArray);
		$attrArray[size($attrArray)] = "defaultRenderGlobals.preRenderLayerMel";
		$attrArray[size($attrArray)] = "defaultRenderGlobals.preRenderLayerMel";
		$attrArray[size($attrArray)] = "defaultRenderGlobals.preRenderMel";
		$attrArray[size($attrArray)] = "defaultRenderGlobals.postRenderMel";

		for ($i = 0; $i < size($attrArray); $i++)
		{
			scriptJob
				-attributeChange 
					$attrArray[$i]
					updateMayaMelCallbacks
				-parent `setParent -query`;
		}
	
	setParent $parent;
	setUITemplate -popTemplate;
}

//==================================================================
// Common Tab
//==================================================================

global proc updateMayaSoftwareCommonGlobalsTab()
{
	//
	// Description:
	//	This procedure is called when the current renderer changes to be the
	//	Maya Software Renderer.
	//	This procedure updates controls in the Common tab of the Maya Software
	//	renderer to reflect values which may have been copied from the previous
	//	current renderer.
	//
	updateMayaSoftwareTargetFilePreview();
	updateMayaSoftwareFileNamePrefixControl();
	updateMayaSoftwareFileNameFormatControl();

	// Must recreate the Image Format option menu because it is renderer specific.
	// This is only required for the master layer layout.
	//
	if( isDisplayingAllRendererTabs()){

		// Set the correct parent
		setParentToCommonTab();
		setParent rgImageFileFrame;

		// Recreate the tab
		createCommonImageFile();
	}
	updateMayaImageFormatControl();

	updateMayaSoftwareUseCustomExtensionControl();
	updateMayaSoftwareCustomExtensionControl();
	updateMayaSoftwareCameraControl();
	updateMayaSoftwareResolution();
	updateMayaMelCallbacks();
}

global proc createMayaSoftwareCommonGlobalsTab()
{
	//
	// Description:
	//	This procedure is called when building the render globals tabs for the
	//	Maya Software renderer.
	//	This procedure builds the "General" tab for the Maya Software renderer.
	//
	string $parentForm = `setParent -query`;

		createTargetFilePreview();

	setParent $parentForm;

    scrollLayout 
		-horizontalScrollBarThickness 0 
		scrollLayout;

		columnLayout 
			-adjustableColumn true
			commonTabColumn;

			// Image File Name
			//
			frameLayout 
				-label "Image File Output" 
				-collapsable true 
				-collapse false
				rgImageFileFrame;
			
				createCommonImageFile();

			setParent commonTabColumn;

			// Resolution ("Image Size") Section
			//
			frameLayout 
				-label "Image Size" 
				-collapsable true 
				-collapse false 
				rgResolutionFrame;

				createCommonResolution(); 

			setParent commonTabColumn;

			// Render Options
			//
			frameLayout 
				-label "Render Options" 
				-collapsable true 
				-collapse false 
				mayaSoftwareOptionFrame;

				createCommonRenderOptions(); 

			setParent commonTabColumn;

    setParent $parentForm;

	formLayout
		-edit 
		-af targetFilePreview "top" 5
		-an targetFilePreview "bottom" 
		-af targetFilePreview "left" 0
		-af targetFilePreview "right" 0
		-ac scrollLayout "top" 5 targetFilePreview
		-af scrollLayout "bottom" 0
		-af scrollLayout "left" 0
		-af scrollLayout "right" 0
		$parentForm;

	// Update the target file preview. 
	//
	updateMayaSoftwareTargetFilePreview;
}

global proc setImageFormat()
{
	int $sel = `optionMenuGrp -q -sl imageMenuMayaSW` - 1;
	string $items[] = `optionMenuGrp -q -itemListShort imageMenuMayaSW`;
	int $val = `menuItem -q -data $items[$sel]`;

	if ($val >= 1000) {
		// Unknown IMF plugin, hence store its key in defaultRenderGlobals
		// imfkey attribute
		//
		global string $imfPlugInKey[];  // This is the unique imf keyword
		setAttr defaultRenderGlobals.imfkey -type "string" $imfPlugInKey[$val-1000];
		setAttr defaultRenderGlobals.imageFormat 50;
	}
	else {
		setAttr defaultRenderGlobals.imageFormat $val;
		setAttr defaultRenderGlobals.imfkey -type "string" "";
	}
}
